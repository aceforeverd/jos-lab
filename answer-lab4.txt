1. what is the purpose of macro MPBOOTPHYS in kern/mpentry.S ?

   MPBOOTPHYS returns the absolute address of a symbol. Without it, it may go to wrong address
   because link address varies with actual load address.


2. It seems that using the big kernel lock guarantees that only one CPU can run the kernel code at a time.

   Why do we still need separate kernel stacks for each CPU?
   Describe a scenario in which using a shared kernel stack will go wrong, even with the protection of the big kernel lock.
   Vulnerable code will likely to damage or leak process info runing on other CPU.
   E.g. the registers of one process was pushed into kernel stack during switching to kernel mode, whic may leak to other process
   when switch back to user mode.

3. In your implementation of env_run() you should have called lcr3(). Before and after the call to lcr3(),
   your code makes references (at least it should) to the variable e, the argument to env_run.
   Upon loading the %cr3 register, the addressing context used by the MMU is instantly changed. But a virtual 
   address (namely e) has meaning relative to a given address context--the address context specifies the 
   physical address to which the virtual address maps. Why can the pointer e be dereferenced both before and
   after the addressing switch?

   all envs are in const positions above UTOP/UENVS
